/**
 * @file bit_traits.h
 * @brief Утилиты для работы с битами.
 *
 * Этот файл содержит макросы для выполнения различных операций с битами,
 * таких как установка, очистка, переключение и проверка состояния битов.
 * Макросы также позволяют выполнять сдвиги и циклические сдвиги битов,
 * а также проверять четность и нечетность чисел.
 *
 * Все макросы используют нумерацию битов, начиная с нуля (0 - младший бит).
 * Убедитесь, что индексы битов и значения не выходят за пределы
 * допустимого диапазона для типа данных, с которым вы работаете.
 *
 * @note Все макросы определены в этом заголовочном файле
 *       и могут быть использованы в любом месте, где он подключен.
 */

#ifndef VI_BIT_TRAITS_H
#define VI_BIT_TRAITS_H

/**
 * @def vi_bit_is_single
 * @brief Проверяет, является ли заданное значение единственным битом.
 *
 * Данный макрос определяет, установлен ли только один бит в заданном значении.
 * Если значение не равно нулю и имеет только один установленный бит,
 * макрос возвращает истинное значение (не ноль). В противном случае
 * возвращает ложное значение (ноль).
 *
 * @param x Значение, которое необходимо проверить.
 * @return Возвращает 1 (истина), если x является единственным битом,
 *         и 0 (ложь) в противном случае.
 */
#define vi_bit_is_single(x) ((x) != 0 && ((x) & ((x)-1)) == 0)

/**
 * @def vi_bit_set
 * @brief Устанавливает указанный бит в заданном значении.
 *
 * Данный макрос устанавливает бит с заданным индексом в значение `x`.
 * Если бит уже установлен, значение `x` не изменится.
 * Индексация битов начинается с нуля (0 - младший бит).
 *
 * @param bit Индекс бита, который необходимо установить.
 * @param x Значение, в котором будет установлен указанный бит.
 * @return Возвращает новое значение `x` с установленным битом.
 */
#define vi_bit_set(bit, x) ((x) | (1 << (bit)))

/**
 * @def vi_bit_clear
 * @brief Очищает указанный бит в заданном значении.
 *
 * Данный макрос очищает бит с заданным индексом в значение `x`.
 * Если бит уже очищен, значение `x` не изменится.
 * Индексация битов начинается с нуля (0 - младший бит).
 *
 * @param bit Индекс бита, который необходимо очистить.
 * @param x Значение, в котором будет очищен указанный бит.
 * @return Возвращает новое значение `x` с очищенным битом.
 */
#define vi_bit_clear(bit, x) ((x) & ~(1 << (bit)))

/**
 * @def vi_bit_toggle
 * @brief Переключает указанный бит в заданном значении.
 *
 * Данный макрос изменяет состояние бита с заданным индексом в значение `x`.
 * Если бит был установлен, он будет очищен, и наоборот.
 * Индексация битов начинается с нуля (0 - младший бит).
 *
 * @param bit Индекс бита, который необходимо переключить.
 * @param x Значение, в котором будет переключен указанный бит.
 * @return Возвращает новое значение `x` с переключенным битом.
 */
#define vi_bit_toggle(bit, x) ((x) ^ (1 << (bit)))

/**
 * @def vi_bit_check
 * @brief Проверяет, установлен ли указанный бит в заданном значении.
 *
 * Данный макрос проверяет, установлен ли бит с заданным индексом в значение `x`.
 * Если бит установлен, макрос возвращает истинное значение (не ноль);
 * если бит не установлен, возвращает ложное значение (ноль).
 * Индексация битов начинается с нуля (0 - младший бит).
 *
 * @param bit Индекс бита, который необходимо проверить.
 * @param x Значение, в котором будет проверяться указанный бит.
 * @return Возвращает 1, если бит установлен, и 0, если бит не установлен.
 */
#define vi_bit_check(bit, x) (((x) & (1 << (bit))) != 0)

/**
 * @def vi_bit_mask
 * @brief Создает маску битов нужной длины.
 *
 * Данный макрос создает маску битов длиной `num_bits`.
 * Маска состоит из единиц в положении битов с 0 по `num_bits - 1` и нулей в остальных битах.
 *
 * @param num_bits Длина маски битов, которую необходимо создать.
 * @return Возвращает маску битов длиной `num_bits`.
 */
#define vi_bit_mask(num_bits) ((1 << (num_bits)) - 1)

/**
 * @def vi_bit_is_even
 * @brief Проверяет, является ли число четным.
 *
 * Данный макрос проверяет, является ли переданное число `x` четным.
 * Число считается четным, если его младший бит равен нулю.
 *
 * @param x Число, которое необходимо проверить на четность.
 * @return Возвращает 1 (истина), если число четное, и 0 (ложь), если число нечетное.
 */
#define vi_bit_is_even(x) (((x)&1) == 0)

/**
 * @def vi_bit_is_odd
 * @brief Проверяет, является ли число нечетным.
 *
 * Данный макрос проверяет, является ли переданное число `x` нечетным.
 * Число считается нечетным, если его младший бит равен единице.
 *
 * @param x Число, которое необходимо проверить на нечетность.
 * @return Возвращает 1 (истина), если число нечетное, и 0 (ложь), если число четное.
 */
#define vi_bit_is_odd(x) (((x)&1) != 0)

/**
 * @def vi_bit_shift_left
 * @brief Сдвигает число влево на заданное количество битов.
 *
 * Данный макрос выполняет сдвиг числа `x` влево на `n` битов.
 * Сдвиг влево эквивалентен умножению числа на 2 в степени `n`.
 *
 * @param x Число, которое необходимо сдвинуть.
 * @param n Количество битов, на которое нужно сдвинуть число влево.
 * @return Результат сдвига числа `x` влево на `n` битов.
 */
#define vi_bit_shift_left(x, n) ((x) << (n))

/**
 * @def vi_bit_shift_right
 * @brief Сдвигает число вправо на заданное количество битов.
 *
 * Данный макрос выполняет сдвиг числа `x` вправо на `n` битов.
 * Сдвиг вправо эквивалентен целочисленному делению числа на 2 в степени `n`.
 *
 * @param x Число, которое необходимо сдвинуть.
 * @param n Количество битов, на которое нужно сдвинуть число вправо.
 * @return Результат сдвига числа `x` вправо на `n` битов.
 */
#define vi_bit_shift_right(x, n) ((x) >> (n))

/**
 * @def vi_bit_rotate_left
 * @brief Выполняет циклический сдвиг числа влево на заданное количество битов.
 *
 * Данный макрос выполняет циклический сдвиг числа `x` влево на `n` битов.
 * Циклический сдвиг влево означает, что биты, которые выходят за пределы
 * самого значимого бита, возвращаются в младшие биты.
 *
 * @param x Число, которое необходимо сдвинуть.
 * @param n Количество битов, на которое нужно сдвинуть число влево.
 * @return Результат циклического сдвига числа `x` влево на `n` битов.
 *
 * @warning Убедитесь, что значение `n` не превышает количество битов в типе `x`.
 */
#define vi_bit_rotate_left(x, n) (((x) << (n)) | ((x) >> (sizeof(x) * 8 - (n))))

/**
 * @def vi_bit_rotate_right
 * @brief Выполняет циклический сдвиг числа вправо на заданное количество битов.
 *
 * Данный макрос выполняет циклический сдвиг числа `x` вправо на `n` битов.
 * Циклический сдвиг вправо означает, что биты, которые выходят за пределы
 * младшего бита, возвращаются в старшие биты.
 *
 * @param x Число, которое необходимо сдвинуть.
 * @param n Количество битов, на которое нужно сдвинуть число вправо.
 * @return Результат циклического сдвига числа `x` вправо на `n` битов.
 *
 * @warning Убедитесь, что значение `n` не превышает количество битов в типе `x`.
 */
#define vi_bit_rotate_right(x, n) (((x) >> (n)) | ((x) << (sizeof(x) * 8 - (n))))

/**
 * @def vi_bit_set_by_index
 * @brief Устанавливает бит в числе по заданному индексу.
 *
 * Данный макрос устанавливает бит в числе `x` на позиции `i` в 1.
 * Это достигается путем побитового ИЛИ с числом, в котором только
 * бит на позиции `i` равен 1, а остальные биты равны 0.
 *
 * @param x Число, в котором необходимо установить бит.
 * @param i Индекс бита, который нужно установить (начиная с 0).
 * @return Результат установки бита в числе `x` на позиции `i`.
 *
 * @warning Убедитесь, что значение `i` не превышает количество битов в типе `x`.
 */
#define vi_bit_set_by_index(x, i) ((x) |= (1ULL << (i)))

/**
 * @def vi_bit_clear_by_index
 * @brief Сбрасывает (обнуляет) бит в числе по заданному индексу.
 *
 * Данный макрос сбрасывает бит в числе `x` на позиции `i` в 0.
 * Это достигается путем побитового И с числом, в котором только
 * бит на позиции `i` равен 0, а остальные биты равны 1.
 *
 * @param x Число, в котором необходимо сбросить бит.
 * @param i Индекс бита, который нужно сбросить (начиная с 0).
 * @return Результат сброса бита в числе `x` на позиции `i`.
 *
 * @warning Убедитесь, что значение `i` не превышает количество битов в типе `x`.
 */
#define vi_bit_clear_by_index(x, i) ((x) &= ~(1ULL << (i)))

/**
 * @def vi_bit_toggle_by_index
 * @brief Переключает (инвертирует) бит в числе по заданному индексу.
 *
 * Данный макрос переключает бит в числе `x` на позиции `i`.
 * Если бит на позиции `i` равен 0, он станет 1, и наоборот.
 * Это достигается путем побитового исключающего ИЛИ с числом,
 * в котором только бит на позиции `i` равен 1, а остальные биты равны 0.
 *
 * @param x Число, в котором необходимо переключить бит.
 * @param i Индекс бита, который нужно переключить (начиная с 0).
 * @return Результат переключения бита в числе `x` на позиции `i`.
 *
 * @warning Убедитесь, что значение `i` не превышает количество битов в типе `x`.
 */
#define vi_bit_toggle_by_index(x, i) ((x) ^= (1ULL << (i)))

/**
 * @def vi_bit_check_by_index
 * @brief Проверяет состояние бита в числе по заданному индексу.
 *
 * Данный макрос проверяет, установлен ли бит в числе `x` на позиции `i`.
 * Если бит на позиции `i` равен 1, макрос возвращает ненулевое значение,
 * в противном случае возвращается 0.
 *
 * Это достигается путем побитового И с числом, в котором только
 * бит на позиции `i` равен 1, а остальные биты равны 0.
 *
 * @param x Число, в котором необходимо проверить состояние бита.
 * @param i Индекс бита, который нужно проверить (начиная с 0).
 * @return Ненулевое значение, если бит на позиции `i` установлен в 1;
 *         0, если бит установлен в 0.
 *
 * @warning Убедитесь, что значение `i` не превышает количество битов в типе `x`.
 */
#define vi_bit_check_by_index(x, i) ((x) & (1ULL << (i)))

/**
 * @def vi_bit_change_by_index
 * @brief Изменяет состояние бита в числе по заданному индексу.
 *
 * Данный макрос изменяет бит в числе `x` на позиции `i` на значение `n`.
 * Если `n` равно 1, бит на позиции `i` будет установлен в 1.
 * Если `n` равно 0, бит будет сброшен в 0.
 *
 * Это достигается путем побитового И с инверсией бита на позиции `i`
 * и побитового ИЛИ с новым значением `n`, сдвинутым на позицию `i`.
 *
 * @param x Число, в котором необходимо изменить состояние бита.
 * @param i Индекс бита, который нужно изменить (начиная с 0).
 * @param n Новое значение бита (0 или 1).
 *
 * @warning Убедитесь, что значение `i` не превышает количество битов в типе `x`.
 *          Значение `n` должно быть равно 0 или 1.
 */
#define vi_bit_change_by_index(x, i, n) ((x) = ((x) & ~(1ULL << (i))) | ((n) << (i)))

#endif // VI_BIT_TRAITS_H
